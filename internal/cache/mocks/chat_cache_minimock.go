// Code generated by http://github.com/gojuno/minimock (v3.3.13). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/lookandhate/course_chat/internal/cache.ChatCache -o chat_cache_minimock.go -n ChatCacheMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/lookandhate/course_chat/internal/service/model"
)

// ChatCacheMock implements cache.ChatCache
type ChatCacheMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateChat          func(ctx context.Context, model *model.ChatModel) (err error)
	inspectFuncCreateChat   func(ctx context.Context, model *model.ChatModel)
	afterCreateChatCounter  uint64
	beforeCreateChatCounter uint64
	CreateChatMock          mChatCacheMockCreateChat

	funcCreateMessage          func(ctx context.Context, model *model.MessageModel) (err error)
	inspectFuncCreateMessage   func(ctx context.Context, model *model.MessageModel)
	afterCreateMessageCounter  uint64
	beforeCreateMessageCounter uint64
	CreateMessageMock          mChatCacheMockCreateMessage

	funcDeleteChat          func(ctx context.Context, id int) (err error)
	inspectFuncDeleteChat   func(ctx context.Context, id int)
	afterDeleteChatCounter  uint64
	beforeDeleteChatCounter uint64
	DeleteChatMock          mChatCacheMockDeleteChat

	funcDeleteMessage          func(ctx context.Context, id int) (err error)
	inspectFuncDeleteMessage   func(ctx context.Context, id int)
	afterDeleteMessageCounter  uint64
	beforeDeleteMessageCounter uint64
	DeleteMessageMock          mChatCacheMockDeleteMessage
}

// NewChatCacheMock returns a mock for cache.ChatCache
func NewChatCacheMock(t minimock.Tester) *ChatCacheMock {
	m := &ChatCacheMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateChatMock = mChatCacheMockCreateChat{mock: m}
	m.CreateChatMock.callArgs = []*ChatCacheMockCreateChatParams{}

	m.CreateMessageMock = mChatCacheMockCreateMessage{mock: m}
	m.CreateMessageMock.callArgs = []*ChatCacheMockCreateMessageParams{}

	m.DeleteChatMock = mChatCacheMockDeleteChat{mock: m}
	m.DeleteChatMock.callArgs = []*ChatCacheMockDeleteChatParams{}

	m.DeleteMessageMock = mChatCacheMockDeleteMessage{mock: m}
	m.DeleteMessageMock.callArgs = []*ChatCacheMockDeleteMessageParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatCacheMockCreateChat struct {
	optional           bool
	mock               *ChatCacheMock
	defaultExpectation *ChatCacheMockCreateChatExpectation
	expectations       []*ChatCacheMockCreateChatExpectation

	callArgs []*ChatCacheMockCreateChatParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatCacheMockCreateChatExpectation specifies expectation struct of the ChatCache.CreateChat
type ChatCacheMockCreateChatExpectation struct {
	mock      *ChatCacheMock
	params    *ChatCacheMockCreateChatParams
	paramPtrs *ChatCacheMockCreateChatParamPtrs
	results   *ChatCacheMockCreateChatResults
	Counter   uint64
}

// ChatCacheMockCreateChatParams contains parameters of the ChatCache.CreateChat
type ChatCacheMockCreateChatParams struct {
	ctx   context.Context
	model *model.ChatModel
}

// ChatCacheMockCreateChatParamPtrs contains pointers to parameters of the ChatCache.CreateChat
type ChatCacheMockCreateChatParamPtrs struct {
	ctx   *context.Context
	model **model.ChatModel
}

// ChatCacheMockCreateChatResults contains results of the ChatCache.CreateChat
type ChatCacheMockCreateChatResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateChat *mChatCacheMockCreateChat) Optional() *mChatCacheMockCreateChat {
	mmCreateChat.optional = true
	return mmCreateChat
}

// Expect sets up expected params for ChatCache.CreateChat
func (mmCreateChat *mChatCacheMockCreateChat) Expect(ctx context.Context, model *model.ChatModel) *mChatCacheMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatCacheMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatCacheMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.paramPtrs != nil {
		mmCreateChat.mock.t.Fatalf("ChatCacheMock.CreateChat mock is already set by ExpectParams functions")
	}

	mmCreateChat.defaultExpectation.params = &ChatCacheMockCreateChatParams{ctx, model}
	for _, e := range mmCreateChat.expectations {
		if minimock.Equal(e.params, mmCreateChat.defaultExpectation.params) {
			mmCreateChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateChat.defaultExpectation.params)
		}
	}

	return mmCreateChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatCache.CreateChat
func (mmCreateChat *mChatCacheMockCreateChat) ExpectCtxParam1(ctx context.Context) *mChatCacheMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatCacheMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatCacheMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.params != nil {
		mmCreateChat.mock.t.Fatalf("ChatCacheMock.CreateChat mock is already set by Expect")
	}

	if mmCreateChat.defaultExpectation.paramPtrs == nil {
		mmCreateChat.defaultExpectation.paramPtrs = &ChatCacheMockCreateChatParamPtrs{}
	}
	mmCreateChat.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateChat
}

// ExpectModelParam2 sets up expected param model for ChatCache.CreateChat
func (mmCreateChat *mChatCacheMockCreateChat) ExpectModelParam2(model *model.ChatModel) *mChatCacheMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatCacheMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatCacheMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.params != nil {
		mmCreateChat.mock.t.Fatalf("ChatCacheMock.CreateChat mock is already set by Expect")
	}

	if mmCreateChat.defaultExpectation.paramPtrs == nil {
		mmCreateChat.defaultExpectation.paramPtrs = &ChatCacheMockCreateChatParamPtrs{}
	}
	mmCreateChat.defaultExpectation.paramPtrs.model = &model

	return mmCreateChat
}

// Inspect accepts an inspector function that has same arguments as the ChatCache.CreateChat
func (mmCreateChat *mChatCacheMockCreateChat) Inspect(f func(ctx context.Context, model *model.ChatModel)) *mChatCacheMockCreateChat {
	if mmCreateChat.mock.inspectFuncCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("Inspect function is already set for ChatCacheMock.CreateChat")
	}

	mmCreateChat.mock.inspectFuncCreateChat = f

	return mmCreateChat
}

// Return sets up results that will be returned by ChatCache.CreateChat
func (mmCreateChat *mChatCacheMockCreateChat) Return(err error) *ChatCacheMock {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatCacheMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatCacheMockCreateChatExpectation{mock: mmCreateChat.mock}
	}
	mmCreateChat.defaultExpectation.results = &ChatCacheMockCreateChatResults{err}
	return mmCreateChat.mock
}

// Set uses given function f to mock the ChatCache.CreateChat method
func (mmCreateChat *mChatCacheMockCreateChat) Set(f func(ctx context.Context, model *model.ChatModel) (err error)) *ChatCacheMock {
	if mmCreateChat.defaultExpectation != nil {
		mmCreateChat.mock.t.Fatalf("Default expectation is already set for the ChatCache.CreateChat method")
	}

	if len(mmCreateChat.expectations) > 0 {
		mmCreateChat.mock.t.Fatalf("Some expectations are already set for the ChatCache.CreateChat method")
	}

	mmCreateChat.mock.funcCreateChat = f
	return mmCreateChat.mock
}

// When sets expectation for the ChatCache.CreateChat which will trigger the result defined by the following
// Then helper
func (mmCreateChat *mChatCacheMockCreateChat) When(ctx context.Context, model *model.ChatModel) *ChatCacheMockCreateChatExpectation {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatCacheMock.CreateChat mock is already set by Set")
	}

	expectation := &ChatCacheMockCreateChatExpectation{
		mock:   mmCreateChat.mock,
		params: &ChatCacheMockCreateChatParams{ctx, model},
	}
	mmCreateChat.expectations = append(mmCreateChat.expectations, expectation)
	return expectation
}

// Then sets up ChatCache.CreateChat return parameters for the expectation previously defined by the When method
func (e *ChatCacheMockCreateChatExpectation) Then(err error) *ChatCacheMock {
	e.results = &ChatCacheMockCreateChatResults{err}
	return e.mock
}

// Times sets number of times ChatCache.CreateChat should be invoked
func (mmCreateChat *mChatCacheMockCreateChat) Times(n uint64) *mChatCacheMockCreateChat {
	if n == 0 {
		mmCreateChat.mock.t.Fatalf("Times of ChatCacheMock.CreateChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateChat.expectedInvocations, n)
	return mmCreateChat
}

func (mmCreateChat *mChatCacheMockCreateChat) invocationsDone() bool {
	if len(mmCreateChat.expectations) == 0 && mmCreateChat.defaultExpectation == nil && mmCreateChat.mock.funcCreateChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateChat.mock.afterCreateChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateChat implements cache.ChatCache
func (mmCreateChat *ChatCacheMock) CreateChat(ctx context.Context, model *model.ChatModel) (err error) {
	mm_atomic.AddUint64(&mmCreateChat.beforeCreateChatCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateChat.afterCreateChatCounter, 1)

	if mmCreateChat.inspectFuncCreateChat != nil {
		mmCreateChat.inspectFuncCreateChat(ctx, model)
	}

	mm_params := ChatCacheMockCreateChatParams{ctx, model}

	// Record call args
	mmCreateChat.CreateChatMock.mutex.Lock()
	mmCreateChat.CreateChatMock.callArgs = append(mmCreateChat.CreateChatMock.callArgs, &mm_params)
	mmCreateChat.CreateChatMock.mutex.Unlock()

	for _, e := range mmCreateChat.CreateChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateChat.CreateChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateChat.CreateChatMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateChat.CreateChatMock.defaultExpectation.params
		mm_want_ptrs := mmCreateChat.CreateChatMock.defaultExpectation.paramPtrs

		mm_got := ChatCacheMockCreateChatParams{ctx, model}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateChat.t.Errorf("ChatCacheMock.CreateChat got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.model != nil && !minimock.Equal(*mm_want_ptrs.model, mm_got.model) {
				mmCreateChat.t.Errorf("ChatCacheMock.CreateChat got unexpected parameter model, want: %#v, got: %#v%s\n", *mm_want_ptrs.model, mm_got.model, minimock.Diff(*mm_want_ptrs.model, mm_got.model))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateChat.t.Errorf("ChatCacheMock.CreateChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateChat.CreateChatMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateChat.t.Fatal("No results are set for the ChatCacheMock.CreateChat")
		}
		return (*mm_results).err
	}
	if mmCreateChat.funcCreateChat != nil {
		return mmCreateChat.funcCreateChat(ctx, model)
	}
	mmCreateChat.t.Fatalf("Unexpected call to ChatCacheMock.CreateChat. %v %v", ctx, model)
	return
}

// CreateChatAfterCounter returns a count of finished ChatCacheMock.CreateChat invocations
func (mmCreateChat *ChatCacheMock) CreateChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.afterCreateChatCounter)
}

// CreateChatBeforeCounter returns a count of ChatCacheMock.CreateChat invocations
func (mmCreateChat *ChatCacheMock) CreateChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.beforeCreateChatCounter)
}

// Calls returns a list of arguments used in each call to ChatCacheMock.CreateChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateChat *mChatCacheMockCreateChat) Calls() []*ChatCacheMockCreateChatParams {
	mmCreateChat.mutex.RLock()

	argCopy := make([]*ChatCacheMockCreateChatParams, len(mmCreateChat.callArgs))
	copy(argCopy, mmCreateChat.callArgs)

	mmCreateChat.mutex.RUnlock()

	return argCopy
}

// MinimockCreateChatDone returns true if the count of the CreateChat invocations corresponds
// the number of defined expectations
func (m *ChatCacheMock) MinimockCreateChatDone() bool {
	if m.CreateChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateChatMock.invocationsDone()
}

// MinimockCreateChatInspect logs each unmet expectation
func (m *ChatCacheMock) MinimockCreateChatInspect() {
	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatCacheMock.CreateChat with params: %#v", *e.params)
		}
	}

	afterCreateChatCounter := mm_atomic.LoadUint64(&m.afterCreateChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatMock.defaultExpectation != nil && afterCreateChatCounter < 1 {
		if m.CreateChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatCacheMock.CreateChat")
		} else {
			m.t.Errorf("Expected call to ChatCacheMock.CreateChat with params: %#v", *m.CreateChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChat != nil && afterCreateChatCounter < 1 {
		m.t.Error("Expected call to ChatCacheMock.CreateChat")
	}

	if !m.CreateChatMock.invocationsDone() && afterCreateChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatCacheMock.CreateChat but found %d calls",
			mm_atomic.LoadUint64(&m.CreateChatMock.expectedInvocations), afterCreateChatCounter)
	}
}

type mChatCacheMockCreateMessage struct {
	optional           bool
	mock               *ChatCacheMock
	defaultExpectation *ChatCacheMockCreateMessageExpectation
	expectations       []*ChatCacheMockCreateMessageExpectation

	callArgs []*ChatCacheMockCreateMessageParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatCacheMockCreateMessageExpectation specifies expectation struct of the ChatCache.CreateMessage
type ChatCacheMockCreateMessageExpectation struct {
	mock      *ChatCacheMock
	params    *ChatCacheMockCreateMessageParams
	paramPtrs *ChatCacheMockCreateMessageParamPtrs
	results   *ChatCacheMockCreateMessageResults
	Counter   uint64
}

// ChatCacheMockCreateMessageParams contains parameters of the ChatCache.CreateMessage
type ChatCacheMockCreateMessageParams struct {
	ctx   context.Context
	model *model.MessageModel
}

// ChatCacheMockCreateMessageParamPtrs contains pointers to parameters of the ChatCache.CreateMessage
type ChatCacheMockCreateMessageParamPtrs struct {
	ctx   *context.Context
	model **model.MessageModel
}

// ChatCacheMockCreateMessageResults contains results of the ChatCache.CreateMessage
type ChatCacheMockCreateMessageResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateMessage *mChatCacheMockCreateMessage) Optional() *mChatCacheMockCreateMessage {
	mmCreateMessage.optional = true
	return mmCreateMessage
}

// Expect sets up expected params for ChatCache.CreateMessage
func (mmCreateMessage *mChatCacheMockCreateMessage) Expect(ctx context.Context, model *model.MessageModel) *mChatCacheMockCreateMessage {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("ChatCacheMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &ChatCacheMockCreateMessageExpectation{}
	}

	if mmCreateMessage.defaultExpectation.paramPtrs != nil {
		mmCreateMessage.mock.t.Fatalf("ChatCacheMock.CreateMessage mock is already set by ExpectParams functions")
	}

	mmCreateMessage.defaultExpectation.params = &ChatCacheMockCreateMessageParams{ctx, model}
	for _, e := range mmCreateMessage.expectations {
		if minimock.Equal(e.params, mmCreateMessage.defaultExpectation.params) {
			mmCreateMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateMessage.defaultExpectation.params)
		}
	}

	return mmCreateMessage
}

// ExpectCtxParam1 sets up expected param ctx for ChatCache.CreateMessage
func (mmCreateMessage *mChatCacheMockCreateMessage) ExpectCtxParam1(ctx context.Context) *mChatCacheMockCreateMessage {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("ChatCacheMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &ChatCacheMockCreateMessageExpectation{}
	}

	if mmCreateMessage.defaultExpectation.params != nil {
		mmCreateMessage.mock.t.Fatalf("ChatCacheMock.CreateMessage mock is already set by Expect")
	}

	if mmCreateMessage.defaultExpectation.paramPtrs == nil {
		mmCreateMessage.defaultExpectation.paramPtrs = &ChatCacheMockCreateMessageParamPtrs{}
	}
	mmCreateMessage.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateMessage
}

// ExpectModelParam2 sets up expected param model for ChatCache.CreateMessage
func (mmCreateMessage *mChatCacheMockCreateMessage) ExpectModelParam2(model *model.MessageModel) *mChatCacheMockCreateMessage {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("ChatCacheMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &ChatCacheMockCreateMessageExpectation{}
	}

	if mmCreateMessage.defaultExpectation.params != nil {
		mmCreateMessage.mock.t.Fatalf("ChatCacheMock.CreateMessage mock is already set by Expect")
	}

	if mmCreateMessage.defaultExpectation.paramPtrs == nil {
		mmCreateMessage.defaultExpectation.paramPtrs = &ChatCacheMockCreateMessageParamPtrs{}
	}
	mmCreateMessage.defaultExpectation.paramPtrs.model = &model

	return mmCreateMessage
}

// Inspect accepts an inspector function that has same arguments as the ChatCache.CreateMessage
func (mmCreateMessage *mChatCacheMockCreateMessage) Inspect(f func(ctx context.Context, model *model.MessageModel)) *mChatCacheMockCreateMessage {
	if mmCreateMessage.mock.inspectFuncCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("Inspect function is already set for ChatCacheMock.CreateMessage")
	}

	mmCreateMessage.mock.inspectFuncCreateMessage = f

	return mmCreateMessage
}

// Return sets up results that will be returned by ChatCache.CreateMessage
func (mmCreateMessage *mChatCacheMockCreateMessage) Return(err error) *ChatCacheMock {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("ChatCacheMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &ChatCacheMockCreateMessageExpectation{mock: mmCreateMessage.mock}
	}
	mmCreateMessage.defaultExpectation.results = &ChatCacheMockCreateMessageResults{err}
	return mmCreateMessage.mock
}

// Set uses given function f to mock the ChatCache.CreateMessage method
func (mmCreateMessage *mChatCacheMockCreateMessage) Set(f func(ctx context.Context, model *model.MessageModel) (err error)) *ChatCacheMock {
	if mmCreateMessage.defaultExpectation != nil {
		mmCreateMessage.mock.t.Fatalf("Default expectation is already set for the ChatCache.CreateMessage method")
	}

	if len(mmCreateMessage.expectations) > 0 {
		mmCreateMessage.mock.t.Fatalf("Some expectations are already set for the ChatCache.CreateMessage method")
	}

	mmCreateMessage.mock.funcCreateMessage = f
	return mmCreateMessage.mock
}

// When sets expectation for the ChatCache.CreateMessage which will trigger the result defined by the following
// Then helper
func (mmCreateMessage *mChatCacheMockCreateMessage) When(ctx context.Context, model *model.MessageModel) *ChatCacheMockCreateMessageExpectation {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("ChatCacheMock.CreateMessage mock is already set by Set")
	}

	expectation := &ChatCacheMockCreateMessageExpectation{
		mock:   mmCreateMessage.mock,
		params: &ChatCacheMockCreateMessageParams{ctx, model},
	}
	mmCreateMessage.expectations = append(mmCreateMessage.expectations, expectation)
	return expectation
}

// Then sets up ChatCache.CreateMessage return parameters for the expectation previously defined by the When method
func (e *ChatCacheMockCreateMessageExpectation) Then(err error) *ChatCacheMock {
	e.results = &ChatCacheMockCreateMessageResults{err}
	return e.mock
}

// Times sets number of times ChatCache.CreateMessage should be invoked
func (mmCreateMessage *mChatCacheMockCreateMessage) Times(n uint64) *mChatCacheMockCreateMessage {
	if n == 0 {
		mmCreateMessage.mock.t.Fatalf("Times of ChatCacheMock.CreateMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateMessage.expectedInvocations, n)
	return mmCreateMessage
}

func (mmCreateMessage *mChatCacheMockCreateMessage) invocationsDone() bool {
	if len(mmCreateMessage.expectations) == 0 && mmCreateMessage.defaultExpectation == nil && mmCreateMessage.mock.funcCreateMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateMessage.mock.afterCreateMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateMessage implements cache.ChatCache
func (mmCreateMessage *ChatCacheMock) CreateMessage(ctx context.Context, model *model.MessageModel) (err error) {
	mm_atomic.AddUint64(&mmCreateMessage.beforeCreateMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateMessage.afterCreateMessageCounter, 1)

	if mmCreateMessage.inspectFuncCreateMessage != nil {
		mmCreateMessage.inspectFuncCreateMessage(ctx, model)
	}

	mm_params := ChatCacheMockCreateMessageParams{ctx, model}

	// Record call args
	mmCreateMessage.CreateMessageMock.mutex.Lock()
	mmCreateMessage.CreateMessageMock.callArgs = append(mmCreateMessage.CreateMessageMock.callArgs, &mm_params)
	mmCreateMessage.CreateMessageMock.mutex.Unlock()

	for _, e := range mmCreateMessage.CreateMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateMessage.CreateMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateMessage.CreateMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateMessage.CreateMessageMock.defaultExpectation.params
		mm_want_ptrs := mmCreateMessage.CreateMessageMock.defaultExpectation.paramPtrs

		mm_got := ChatCacheMockCreateMessageParams{ctx, model}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateMessage.t.Errorf("ChatCacheMock.CreateMessage got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.model != nil && !minimock.Equal(*mm_want_ptrs.model, mm_got.model) {
				mmCreateMessage.t.Errorf("ChatCacheMock.CreateMessage got unexpected parameter model, want: %#v, got: %#v%s\n", *mm_want_ptrs.model, mm_got.model, minimock.Diff(*mm_want_ptrs.model, mm_got.model))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateMessage.t.Errorf("ChatCacheMock.CreateMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateMessage.CreateMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateMessage.t.Fatal("No results are set for the ChatCacheMock.CreateMessage")
		}
		return (*mm_results).err
	}
	if mmCreateMessage.funcCreateMessage != nil {
		return mmCreateMessage.funcCreateMessage(ctx, model)
	}
	mmCreateMessage.t.Fatalf("Unexpected call to ChatCacheMock.CreateMessage. %v %v", ctx, model)
	return
}

// CreateMessageAfterCounter returns a count of finished ChatCacheMock.CreateMessage invocations
func (mmCreateMessage *ChatCacheMock) CreateMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateMessage.afterCreateMessageCounter)
}

// CreateMessageBeforeCounter returns a count of ChatCacheMock.CreateMessage invocations
func (mmCreateMessage *ChatCacheMock) CreateMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateMessage.beforeCreateMessageCounter)
}

// Calls returns a list of arguments used in each call to ChatCacheMock.CreateMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateMessage *mChatCacheMockCreateMessage) Calls() []*ChatCacheMockCreateMessageParams {
	mmCreateMessage.mutex.RLock()

	argCopy := make([]*ChatCacheMockCreateMessageParams, len(mmCreateMessage.callArgs))
	copy(argCopy, mmCreateMessage.callArgs)

	mmCreateMessage.mutex.RUnlock()

	return argCopy
}

// MinimockCreateMessageDone returns true if the count of the CreateMessage invocations corresponds
// the number of defined expectations
func (m *ChatCacheMock) MinimockCreateMessageDone() bool {
	if m.CreateMessageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMessageMock.invocationsDone()
}

// MinimockCreateMessageInspect logs each unmet expectation
func (m *ChatCacheMock) MinimockCreateMessageInspect() {
	for _, e := range m.CreateMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatCacheMock.CreateMessage with params: %#v", *e.params)
		}
	}

	afterCreateMessageCounter := mm_atomic.LoadUint64(&m.afterCreateMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMessageMock.defaultExpectation != nil && afterCreateMessageCounter < 1 {
		if m.CreateMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatCacheMock.CreateMessage")
		} else {
			m.t.Errorf("Expected call to ChatCacheMock.CreateMessage with params: %#v", *m.CreateMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateMessage != nil && afterCreateMessageCounter < 1 {
		m.t.Error("Expected call to ChatCacheMock.CreateMessage")
	}

	if !m.CreateMessageMock.invocationsDone() && afterCreateMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatCacheMock.CreateMessage but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMessageMock.expectedInvocations), afterCreateMessageCounter)
	}
}

type mChatCacheMockDeleteChat struct {
	optional           bool
	mock               *ChatCacheMock
	defaultExpectation *ChatCacheMockDeleteChatExpectation
	expectations       []*ChatCacheMockDeleteChatExpectation

	callArgs []*ChatCacheMockDeleteChatParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatCacheMockDeleteChatExpectation specifies expectation struct of the ChatCache.DeleteChat
type ChatCacheMockDeleteChatExpectation struct {
	mock      *ChatCacheMock
	params    *ChatCacheMockDeleteChatParams
	paramPtrs *ChatCacheMockDeleteChatParamPtrs
	results   *ChatCacheMockDeleteChatResults
	Counter   uint64
}

// ChatCacheMockDeleteChatParams contains parameters of the ChatCache.DeleteChat
type ChatCacheMockDeleteChatParams struct {
	ctx context.Context
	id  int
}

// ChatCacheMockDeleteChatParamPtrs contains pointers to parameters of the ChatCache.DeleteChat
type ChatCacheMockDeleteChatParamPtrs struct {
	ctx *context.Context
	id  *int
}

// ChatCacheMockDeleteChatResults contains results of the ChatCache.DeleteChat
type ChatCacheMockDeleteChatResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteChat *mChatCacheMockDeleteChat) Optional() *mChatCacheMockDeleteChat {
	mmDeleteChat.optional = true
	return mmDeleteChat
}

// Expect sets up expected params for ChatCache.DeleteChat
func (mmDeleteChat *mChatCacheMockDeleteChat) Expect(ctx context.Context, id int) *mChatCacheMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatCacheMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatCacheMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.paramPtrs != nil {
		mmDeleteChat.mock.t.Fatalf("ChatCacheMock.DeleteChat mock is already set by ExpectParams functions")
	}

	mmDeleteChat.defaultExpectation.params = &ChatCacheMockDeleteChatParams{ctx, id}
	for _, e := range mmDeleteChat.expectations {
		if minimock.Equal(e.params, mmDeleteChat.defaultExpectation.params) {
			mmDeleteChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChat.defaultExpectation.params)
		}
	}

	return mmDeleteChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatCache.DeleteChat
func (mmDeleteChat *mChatCacheMockDeleteChat) ExpectCtxParam1(ctx context.Context) *mChatCacheMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatCacheMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatCacheMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.params != nil {
		mmDeleteChat.mock.t.Fatalf("ChatCacheMock.DeleteChat mock is already set by Expect")
	}

	if mmDeleteChat.defaultExpectation.paramPtrs == nil {
		mmDeleteChat.defaultExpectation.paramPtrs = &ChatCacheMockDeleteChatParamPtrs{}
	}
	mmDeleteChat.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteChat
}

// ExpectIdParam2 sets up expected param id for ChatCache.DeleteChat
func (mmDeleteChat *mChatCacheMockDeleteChat) ExpectIdParam2(id int) *mChatCacheMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatCacheMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatCacheMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.params != nil {
		mmDeleteChat.mock.t.Fatalf("ChatCacheMock.DeleteChat mock is already set by Expect")
	}

	if mmDeleteChat.defaultExpectation.paramPtrs == nil {
		mmDeleteChat.defaultExpectation.paramPtrs = &ChatCacheMockDeleteChatParamPtrs{}
	}
	mmDeleteChat.defaultExpectation.paramPtrs.id = &id

	return mmDeleteChat
}

// Inspect accepts an inspector function that has same arguments as the ChatCache.DeleteChat
func (mmDeleteChat *mChatCacheMockDeleteChat) Inspect(f func(ctx context.Context, id int)) *mChatCacheMockDeleteChat {
	if mmDeleteChat.mock.inspectFuncDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("Inspect function is already set for ChatCacheMock.DeleteChat")
	}

	mmDeleteChat.mock.inspectFuncDeleteChat = f

	return mmDeleteChat
}

// Return sets up results that will be returned by ChatCache.DeleteChat
func (mmDeleteChat *mChatCacheMockDeleteChat) Return(err error) *ChatCacheMock {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatCacheMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatCacheMockDeleteChatExpectation{mock: mmDeleteChat.mock}
	}
	mmDeleteChat.defaultExpectation.results = &ChatCacheMockDeleteChatResults{err}
	return mmDeleteChat.mock
}

// Set uses given function f to mock the ChatCache.DeleteChat method
func (mmDeleteChat *mChatCacheMockDeleteChat) Set(f func(ctx context.Context, id int) (err error)) *ChatCacheMock {
	if mmDeleteChat.defaultExpectation != nil {
		mmDeleteChat.mock.t.Fatalf("Default expectation is already set for the ChatCache.DeleteChat method")
	}

	if len(mmDeleteChat.expectations) > 0 {
		mmDeleteChat.mock.t.Fatalf("Some expectations are already set for the ChatCache.DeleteChat method")
	}

	mmDeleteChat.mock.funcDeleteChat = f
	return mmDeleteChat.mock
}

// When sets expectation for the ChatCache.DeleteChat which will trigger the result defined by the following
// Then helper
func (mmDeleteChat *mChatCacheMockDeleteChat) When(ctx context.Context, id int) *ChatCacheMockDeleteChatExpectation {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatCacheMock.DeleteChat mock is already set by Set")
	}

	expectation := &ChatCacheMockDeleteChatExpectation{
		mock:   mmDeleteChat.mock,
		params: &ChatCacheMockDeleteChatParams{ctx, id},
	}
	mmDeleteChat.expectations = append(mmDeleteChat.expectations, expectation)
	return expectation
}

// Then sets up ChatCache.DeleteChat return parameters for the expectation previously defined by the When method
func (e *ChatCacheMockDeleteChatExpectation) Then(err error) *ChatCacheMock {
	e.results = &ChatCacheMockDeleteChatResults{err}
	return e.mock
}

// Times sets number of times ChatCache.DeleteChat should be invoked
func (mmDeleteChat *mChatCacheMockDeleteChat) Times(n uint64) *mChatCacheMockDeleteChat {
	if n == 0 {
		mmDeleteChat.mock.t.Fatalf("Times of ChatCacheMock.DeleteChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteChat.expectedInvocations, n)
	return mmDeleteChat
}

func (mmDeleteChat *mChatCacheMockDeleteChat) invocationsDone() bool {
	if len(mmDeleteChat.expectations) == 0 && mmDeleteChat.defaultExpectation == nil && mmDeleteChat.mock.funcDeleteChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteChat.mock.afterDeleteChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteChat implements cache.ChatCache
func (mmDeleteChat *ChatCacheMock) DeleteChat(ctx context.Context, id int) (err error) {
	mm_atomic.AddUint64(&mmDeleteChat.beforeDeleteChatCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChat.afterDeleteChatCounter, 1)

	if mmDeleteChat.inspectFuncDeleteChat != nil {
		mmDeleteChat.inspectFuncDeleteChat(ctx, id)
	}

	mm_params := ChatCacheMockDeleteChatParams{ctx, id}

	// Record call args
	mmDeleteChat.DeleteChatMock.mutex.Lock()
	mmDeleteChat.DeleteChatMock.callArgs = append(mmDeleteChat.DeleteChatMock.callArgs, &mm_params)
	mmDeleteChat.DeleteChatMock.mutex.Unlock()

	for _, e := range mmDeleteChat.DeleteChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteChat.DeleteChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChat.DeleteChatMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChat.DeleteChatMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteChat.DeleteChatMock.defaultExpectation.paramPtrs

		mm_got := ChatCacheMockDeleteChatParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteChat.t.Errorf("ChatCacheMock.DeleteChat got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteChat.t.Errorf("ChatCacheMock.DeleteChat got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChat.t.Errorf("ChatCacheMock.DeleteChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChat.DeleteChatMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChat.t.Fatal("No results are set for the ChatCacheMock.DeleteChat")
		}
		return (*mm_results).err
	}
	if mmDeleteChat.funcDeleteChat != nil {
		return mmDeleteChat.funcDeleteChat(ctx, id)
	}
	mmDeleteChat.t.Fatalf("Unexpected call to ChatCacheMock.DeleteChat. %v %v", ctx, id)
	return
}

// DeleteChatAfterCounter returns a count of finished ChatCacheMock.DeleteChat invocations
func (mmDeleteChat *ChatCacheMock) DeleteChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.afterDeleteChatCounter)
}

// DeleteChatBeforeCounter returns a count of ChatCacheMock.DeleteChat invocations
func (mmDeleteChat *ChatCacheMock) DeleteChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.beforeDeleteChatCounter)
}

// Calls returns a list of arguments used in each call to ChatCacheMock.DeleteChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChat *mChatCacheMockDeleteChat) Calls() []*ChatCacheMockDeleteChatParams {
	mmDeleteChat.mutex.RLock()

	argCopy := make([]*ChatCacheMockDeleteChatParams, len(mmDeleteChat.callArgs))
	copy(argCopy, mmDeleteChat.callArgs)

	mmDeleteChat.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChatDone returns true if the count of the DeleteChat invocations corresponds
// the number of defined expectations
func (m *ChatCacheMock) MinimockDeleteChatDone() bool {
	if m.DeleteChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteChatMock.invocationsDone()
}

// MinimockDeleteChatInspect logs each unmet expectation
func (m *ChatCacheMock) MinimockDeleteChatInspect() {
	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatCacheMock.DeleteChat with params: %#v", *e.params)
		}
	}

	afterDeleteChatCounter := mm_atomic.LoadUint64(&m.afterDeleteChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatMock.defaultExpectation != nil && afterDeleteChatCounter < 1 {
		if m.DeleteChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatCacheMock.DeleteChat")
		} else {
			m.t.Errorf("Expected call to ChatCacheMock.DeleteChat with params: %#v", *m.DeleteChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChat != nil && afterDeleteChatCounter < 1 {
		m.t.Error("Expected call to ChatCacheMock.DeleteChat")
	}

	if !m.DeleteChatMock.invocationsDone() && afterDeleteChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatCacheMock.DeleteChat but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteChatMock.expectedInvocations), afterDeleteChatCounter)
	}
}

type mChatCacheMockDeleteMessage struct {
	optional           bool
	mock               *ChatCacheMock
	defaultExpectation *ChatCacheMockDeleteMessageExpectation
	expectations       []*ChatCacheMockDeleteMessageExpectation

	callArgs []*ChatCacheMockDeleteMessageParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatCacheMockDeleteMessageExpectation specifies expectation struct of the ChatCache.DeleteMessage
type ChatCacheMockDeleteMessageExpectation struct {
	mock      *ChatCacheMock
	params    *ChatCacheMockDeleteMessageParams
	paramPtrs *ChatCacheMockDeleteMessageParamPtrs
	results   *ChatCacheMockDeleteMessageResults
	Counter   uint64
}

// ChatCacheMockDeleteMessageParams contains parameters of the ChatCache.DeleteMessage
type ChatCacheMockDeleteMessageParams struct {
	ctx context.Context
	id  int
}

// ChatCacheMockDeleteMessageParamPtrs contains pointers to parameters of the ChatCache.DeleteMessage
type ChatCacheMockDeleteMessageParamPtrs struct {
	ctx *context.Context
	id  *int
}

// ChatCacheMockDeleteMessageResults contains results of the ChatCache.DeleteMessage
type ChatCacheMockDeleteMessageResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteMessage *mChatCacheMockDeleteMessage) Optional() *mChatCacheMockDeleteMessage {
	mmDeleteMessage.optional = true
	return mmDeleteMessage
}

// Expect sets up expected params for ChatCache.DeleteMessage
func (mmDeleteMessage *mChatCacheMockDeleteMessage) Expect(ctx context.Context, id int) *mChatCacheMockDeleteMessage {
	if mmDeleteMessage.mock.funcDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("ChatCacheMock.DeleteMessage mock is already set by Set")
	}

	if mmDeleteMessage.defaultExpectation == nil {
		mmDeleteMessage.defaultExpectation = &ChatCacheMockDeleteMessageExpectation{}
	}

	if mmDeleteMessage.defaultExpectation.paramPtrs != nil {
		mmDeleteMessage.mock.t.Fatalf("ChatCacheMock.DeleteMessage mock is already set by ExpectParams functions")
	}

	mmDeleteMessage.defaultExpectation.params = &ChatCacheMockDeleteMessageParams{ctx, id}
	for _, e := range mmDeleteMessage.expectations {
		if minimock.Equal(e.params, mmDeleteMessage.defaultExpectation.params) {
			mmDeleteMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteMessage.defaultExpectation.params)
		}
	}

	return mmDeleteMessage
}

// ExpectCtxParam1 sets up expected param ctx for ChatCache.DeleteMessage
func (mmDeleteMessage *mChatCacheMockDeleteMessage) ExpectCtxParam1(ctx context.Context) *mChatCacheMockDeleteMessage {
	if mmDeleteMessage.mock.funcDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("ChatCacheMock.DeleteMessage mock is already set by Set")
	}

	if mmDeleteMessage.defaultExpectation == nil {
		mmDeleteMessage.defaultExpectation = &ChatCacheMockDeleteMessageExpectation{}
	}

	if mmDeleteMessage.defaultExpectation.params != nil {
		mmDeleteMessage.mock.t.Fatalf("ChatCacheMock.DeleteMessage mock is already set by Expect")
	}

	if mmDeleteMessage.defaultExpectation.paramPtrs == nil {
		mmDeleteMessage.defaultExpectation.paramPtrs = &ChatCacheMockDeleteMessageParamPtrs{}
	}
	mmDeleteMessage.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteMessage
}

// ExpectIdParam2 sets up expected param id for ChatCache.DeleteMessage
func (mmDeleteMessage *mChatCacheMockDeleteMessage) ExpectIdParam2(id int) *mChatCacheMockDeleteMessage {
	if mmDeleteMessage.mock.funcDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("ChatCacheMock.DeleteMessage mock is already set by Set")
	}

	if mmDeleteMessage.defaultExpectation == nil {
		mmDeleteMessage.defaultExpectation = &ChatCacheMockDeleteMessageExpectation{}
	}

	if mmDeleteMessage.defaultExpectation.params != nil {
		mmDeleteMessage.mock.t.Fatalf("ChatCacheMock.DeleteMessage mock is already set by Expect")
	}

	if mmDeleteMessage.defaultExpectation.paramPtrs == nil {
		mmDeleteMessage.defaultExpectation.paramPtrs = &ChatCacheMockDeleteMessageParamPtrs{}
	}
	mmDeleteMessage.defaultExpectation.paramPtrs.id = &id

	return mmDeleteMessage
}

// Inspect accepts an inspector function that has same arguments as the ChatCache.DeleteMessage
func (mmDeleteMessage *mChatCacheMockDeleteMessage) Inspect(f func(ctx context.Context, id int)) *mChatCacheMockDeleteMessage {
	if mmDeleteMessage.mock.inspectFuncDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("Inspect function is already set for ChatCacheMock.DeleteMessage")
	}

	mmDeleteMessage.mock.inspectFuncDeleteMessage = f

	return mmDeleteMessage
}

// Return sets up results that will be returned by ChatCache.DeleteMessage
func (mmDeleteMessage *mChatCacheMockDeleteMessage) Return(err error) *ChatCacheMock {
	if mmDeleteMessage.mock.funcDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("ChatCacheMock.DeleteMessage mock is already set by Set")
	}

	if mmDeleteMessage.defaultExpectation == nil {
		mmDeleteMessage.defaultExpectation = &ChatCacheMockDeleteMessageExpectation{mock: mmDeleteMessage.mock}
	}
	mmDeleteMessage.defaultExpectation.results = &ChatCacheMockDeleteMessageResults{err}
	return mmDeleteMessage.mock
}

// Set uses given function f to mock the ChatCache.DeleteMessage method
func (mmDeleteMessage *mChatCacheMockDeleteMessage) Set(f func(ctx context.Context, id int) (err error)) *ChatCacheMock {
	if mmDeleteMessage.defaultExpectation != nil {
		mmDeleteMessage.mock.t.Fatalf("Default expectation is already set for the ChatCache.DeleteMessage method")
	}

	if len(mmDeleteMessage.expectations) > 0 {
		mmDeleteMessage.mock.t.Fatalf("Some expectations are already set for the ChatCache.DeleteMessage method")
	}

	mmDeleteMessage.mock.funcDeleteMessage = f
	return mmDeleteMessage.mock
}

// When sets expectation for the ChatCache.DeleteMessage which will trigger the result defined by the following
// Then helper
func (mmDeleteMessage *mChatCacheMockDeleteMessage) When(ctx context.Context, id int) *ChatCacheMockDeleteMessageExpectation {
	if mmDeleteMessage.mock.funcDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("ChatCacheMock.DeleteMessage mock is already set by Set")
	}

	expectation := &ChatCacheMockDeleteMessageExpectation{
		mock:   mmDeleteMessage.mock,
		params: &ChatCacheMockDeleteMessageParams{ctx, id},
	}
	mmDeleteMessage.expectations = append(mmDeleteMessage.expectations, expectation)
	return expectation
}

// Then sets up ChatCache.DeleteMessage return parameters for the expectation previously defined by the When method
func (e *ChatCacheMockDeleteMessageExpectation) Then(err error) *ChatCacheMock {
	e.results = &ChatCacheMockDeleteMessageResults{err}
	return e.mock
}

// Times sets number of times ChatCache.DeleteMessage should be invoked
func (mmDeleteMessage *mChatCacheMockDeleteMessage) Times(n uint64) *mChatCacheMockDeleteMessage {
	if n == 0 {
		mmDeleteMessage.mock.t.Fatalf("Times of ChatCacheMock.DeleteMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteMessage.expectedInvocations, n)
	return mmDeleteMessage
}

func (mmDeleteMessage *mChatCacheMockDeleteMessage) invocationsDone() bool {
	if len(mmDeleteMessage.expectations) == 0 && mmDeleteMessage.defaultExpectation == nil && mmDeleteMessage.mock.funcDeleteMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteMessage.mock.afterDeleteMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteMessage implements cache.ChatCache
func (mmDeleteMessage *ChatCacheMock) DeleteMessage(ctx context.Context, id int) (err error) {
	mm_atomic.AddUint64(&mmDeleteMessage.beforeDeleteMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteMessage.afterDeleteMessageCounter, 1)

	if mmDeleteMessage.inspectFuncDeleteMessage != nil {
		mmDeleteMessage.inspectFuncDeleteMessage(ctx, id)
	}

	mm_params := ChatCacheMockDeleteMessageParams{ctx, id}

	// Record call args
	mmDeleteMessage.DeleteMessageMock.mutex.Lock()
	mmDeleteMessage.DeleteMessageMock.callArgs = append(mmDeleteMessage.DeleteMessageMock.callArgs, &mm_params)
	mmDeleteMessage.DeleteMessageMock.mutex.Unlock()

	for _, e := range mmDeleteMessage.DeleteMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteMessage.DeleteMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteMessage.DeleteMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteMessage.DeleteMessageMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteMessage.DeleteMessageMock.defaultExpectation.paramPtrs

		mm_got := ChatCacheMockDeleteMessageParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteMessage.t.Errorf("ChatCacheMock.DeleteMessage got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteMessage.t.Errorf("ChatCacheMock.DeleteMessage got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteMessage.t.Errorf("ChatCacheMock.DeleteMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteMessage.DeleteMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteMessage.t.Fatal("No results are set for the ChatCacheMock.DeleteMessage")
		}
		return (*mm_results).err
	}
	if mmDeleteMessage.funcDeleteMessage != nil {
		return mmDeleteMessage.funcDeleteMessage(ctx, id)
	}
	mmDeleteMessage.t.Fatalf("Unexpected call to ChatCacheMock.DeleteMessage. %v %v", ctx, id)
	return
}

// DeleteMessageAfterCounter returns a count of finished ChatCacheMock.DeleteMessage invocations
func (mmDeleteMessage *ChatCacheMock) DeleteMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteMessage.afterDeleteMessageCounter)
}

// DeleteMessageBeforeCounter returns a count of ChatCacheMock.DeleteMessage invocations
func (mmDeleteMessage *ChatCacheMock) DeleteMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteMessage.beforeDeleteMessageCounter)
}

// Calls returns a list of arguments used in each call to ChatCacheMock.DeleteMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteMessage *mChatCacheMockDeleteMessage) Calls() []*ChatCacheMockDeleteMessageParams {
	mmDeleteMessage.mutex.RLock()

	argCopy := make([]*ChatCacheMockDeleteMessageParams, len(mmDeleteMessage.callArgs))
	copy(argCopy, mmDeleteMessage.callArgs)

	mmDeleteMessage.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteMessageDone returns true if the count of the DeleteMessage invocations corresponds
// the number of defined expectations
func (m *ChatCacheMock) MinimockDeleteMessageDone() bool {
	if m.DeleteMessageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMessageMock.invocationsDone()
}

// MinimockDeleteMessageInspect logs each unmet expectation
func (m *ChatCacheMock) MinimockDeleteMessageInspect() {
	for _, e := range m.DeleteMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatCacheMock.DeleteMessage with params: %#v", *e.params)
		}
	}

	afterDeleteMessageCounter := mm_atomic.LoadUint64(&m.afterDeleteMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMessageMock.defaultExpectation != nil && afterDeleteMessageCounter < 1 {
		if m.DeleteMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatCacheMock.DeleteMessage")
		} else {
			m.t.Errorf("Expected call to ChatCacheMock.DeleteMessage with params: %#v", *m.DeleteMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteMessage != nil && afterDeleteMessageCounter < 1 {
		m.t.Error("Expected call to ChatCacheMock.DeleteMessage")
	}

	if !m.DeleteMessageMock.invocationsDone() && afterDeleteMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatCacheMock.DeleteMessage but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMessageMock.expectedInvocations), afterDeleteMessageCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatCacheMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateChatInspect()

			m.MinimockCreateMessageInspect()

			m.MinimockDeleteChatInspect()

			m.MinimockDeleteMessageInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatCacheMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatCacheMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateChatDone() &&
		m.MinimockCreateMessageDone() &&
		m.MinimockDeleteChatDone() &&
		m.MinimockDeleteMessageDone()
}
